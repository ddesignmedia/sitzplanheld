<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sitzplanheld</title>
    <!-- Lokale Skripte für PDF-Export. Stellen Sie sicher, dass diese Dateien im selben Ordner liegen. -->
    <script src="html2canvas.min.js"></script>
    <script src="jspdf.umd.min.js"></script>
    
    <!-- 
        Alle Styles wurden von Tailwind CSS in reines CSS umgewandelt, um externe Abhängigkeiten zu entfernen.
        Google Fonts wurden durch system-sichere Schriftarten (Arial, Helvetica) ersetzt.
    -->
    <style>
        /* --- Allgemeine Styles & Resets --- */
        :root {
            --color-gray-50: #F9FAFB;
            --color-gray-200: #E5E7EB;
            --color-gray-300: #D1D5DB;
            --color-gray-500: #6B7280;
            --color-gray-600: #4B5563;
            --color-gray-700: #374151;
            --color-slate-100: #f1f5f9;
            --color-slate-200: #e2e8f0;
            --color-slate-300: #cbd5e1;
            --color-slate-400: #94a3b8;
            --color-slate-500: #64748b;
            --color-slate-700: #334155;
            --color-blue-500: #3B82F6;
            --color-blue-600: #2563EB;
            --color-blue-800: #1e40af;
            --color-green-600: #16A34A;
            --color-green-700: #15803D;
            --color-red-500: #EF4444;
            --color-red-600: #DC2626;
            --color-white: #FFFFFF;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: Arial, Helvetica, sans-serif;
            background-color: var(--color-gray-50);
            margin: 0;
            padding: 0;
        }

        .container {
            width: 100%;
            padding-left: 1rem;
            padding-right: 1rem;
            margin-left: auto;
            margin-right: auto;
        }
        @media (min-width: 640px) { .container { max-width: 640px; } }
        @media (min-width: 768px) { .container { max-width: 768px; } }
        @media (min-width: 1024px) { .container { max-width: 1024px; } }
        @media (min-width: 1280px) { .container { max-width: 1280px; } }
        @media (min-width: 1536px) { .container { max-width: 1536px; } }

        /* --- Banner --- */
        #bannerOuterContainer {
            background-color: var(--color-white);
            padding: 1.25rem;
            border-radius: 0.75rem;
            box-shadow: var(--shadow-lg);
            margin: 1.5rem auto 2rem auto;
            max-width: 80rem;
        }
        #bannerContainer {
            width: 100%;
            text-align: center;
        }
        #bannerImage {
            max-width: 100%;
            height: auto;
            max-height: 200px;
            object-fit: contain;
            border-radius: 0.75rem;
        }
        
        /* --- Tabs --- */
        #tabBar {
            display: flex;
            border-bottom: 1px solid var(--color-gray-300);
            margin-bottom: 0.25rem;
        }
        .tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-right: 2px;
            background-color: var(--color-gray-200);
            border-top-left-radius: 0.375rem;
            border-top-right-radius: 0.375rem;
            position: relative;
            display: flex;
            align-items: center;
        }
        .tab.active {
            background-color: var(--color-white);
            border-color: var(--color-gray-300);
            border-bottom: 1px solid var(--color-white);
            z-index: 10;
        }
        #addTabButton {
            margin-left: 0.5rem;
            padding: 0.25rem 0.75rem;
            font-size: 1.125rem;
            font-weight: 700;
            color: var(--color-blue-600);
            background: none;
            border: none;
            cursor: pointer;
        }
        #addTabButton:hover { color: var(--color-blue-800); }
        .tab-name-display { min-width: 80px; display: inline-block; padding-right: 5px; }
        .tab-input { border: 1px solid var(--color-blue-500); background-color: var(--color-white); outline: none; width: 100px; padding: 1px 3px; font-size: inherit; font-family: inherit; }
        .tab-action-icon { margin-left: 8px; font-size: 0.9rem; color: #9ca3af; cursor: pointer; padding: 0 4px; }
        .tab-action-icon:hover { color: #374151; }

        /* --- Controls & Inputs --- */
        .controls {
            background-color: var(--color-white);
            padding: 1.25rem;
            border-bottom-left-radius: 0.75rem;
            border-bottom-right-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            box-shadow: var(--shadow-lg);
            margin-bottom: 2rem;
        }
        .controls-grid {
            display: grid;
            grid-template-columns: repeat(1, minmax(0, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        @media (min-width: 768px) { .controls-grid { grid-template-columns: repeat(3, minmax(0, 1fr)); } }
        
        .input-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--color-gray-700);
            margin-bottom: 0.25rem;
        }
        .input-field, .textarea-field {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid var(--color-gray-300);
            border-radius: 0.5rem;
            box-shadow: var(--shadow-sm);
            transition: border-color 150ms ease-in-out, box-shadow 150ms ease-in-out;
            box-sizing: border-box; /* Wichtig für korrekte Breite */
        }
        .input-field:focus, .textarea-field:focus {
            outline: none;
            border-color: var(--color-blue-500);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }
        .textarea-field {
            resize: vertical;
        }
        
        /* --- Buttons --- */
        .buttons-container {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
        }
        .buttons-container.small-margin { margin-top: 0.75rem; }

        .control-button-large {
            width: 110px;
            height: 50px;
            background-color: var(--color-slate-100);
            color: var(--color-slate-700);
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-md);
            transition: all 150ms ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
        }
        .control-button-large:hover {
            background-color: var(--color-slate-200);
            box-shadow: var(--shadow-lg);
        }
        .control-button-large .text {
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
        }

        .control-button-small {
            width: 90px;
            height: 40px;
            padding: 0.5rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-md);
            transition: all 150ms ease-in-out;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            cursor: pointer;
        }
        .control-button-small:hover { box-shadow: var(--shadow-lg); }
        .control-button-small .text {
            font-size: 0.875rem;
            font-weight: 500;
            text-align: center;
        }

        #insertTestClassButton { background-color: var(--color-slate-300); color: var(--color-slate-700); }
        #insertTestClassButton:hover { background-color: var(--color-slate-400); }
        #savePlanButton, #loadPlanButton, #downloadPdfButton { background-color: var(--color-slate-200); color: var(--color-slate-700); }
        #savePlanButton:hover, #loadPlanButton:hover, #downloadPdfButton:hover { background-color: var(--color-slate-300); }

        #messageArea {
            margin-top: 0.75rem;
            font-size: 0.875rem;
            color: var(--color-red-600);
            text-align: center;
            min-height: 1.25em;
        }
        
        /* --- Editor Panels (Room, Group) --- */
        .editor-panel {
            background-color: var(--color-white);
            padding: 1.25rem;
            border-radius: 0.75rem;
            box-shadow: var(--shadow-lg);
            margin-bottom: 2rem;
        }
        .editor-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: var(--color-gray-700);
            text-align: center;
        }
        .editor-description {
            font-size: 0.875rem;
            color: var(--color-gray-600);
            margin-bottom: 0.75rem;
            text-align: center;
        }
        .editor-button-container {
            margin-top: 1rem;
            display: flex;
            justify-content: center;
        }
        .editor-button {
            color: var(--color-white);
            font-weight: 600;
            padding: 0.5rem 1.25rem;
            border-radius: 0.5rem;
            box-shadow: var(--shadow-md);
            border: none;
            cursor: pointer;
            transition: background-color 150ms ease-in-out;
        }
        #applyLayoutButton { background-color: var(--color-green-600); }
        #applyLayoutButton:hover { background-color: var(--color-green-700); }
        #generateRandomGroupsButton { margin-top: 0.5rem; width: 100%; background-color: var(--color-blue-500); }
        #generateRandomGroupsButton:hover { background-color: var(--color-blue-600); }
        #closeGroupEditorButton { background-color: var(--color-gray-500); }
        #closeGroupEditorButton:hover { background-color: var(--color-gray-600); }

        /* --- Room Editor Grid --- */
        #roomEditorGrid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 2px;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            padding: 5px;
            background-color: #f9f9f9;
            max-width: 450px;
            margin-left: auto;
            margin-right: auto;
        }
        .editor-cell {
            width: 100%;
            padding-bottom: 100%;
            background-color: #e0e0e0;
            border: 1px solid #bdbdbd;
            cursor: pointer;
            position: relative;
        }
        .editor-cell.selected { background-color: #60A5FA; border: 1px solid #2563EB; }
        .editor-cell span { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 0.7rem; color: #555; }
        .editor-cell.selected span { color: var(--color-white); }
        
        /* --- Group Editor --- */
        #groupEditorColorSwatches { margin-bottom: 1rem; }
        .color-swatch-row { display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; margin-bottom: 5px; }
        .color-swatch { width: 40px; height: 40px; border: 1px solid #ccc; border-radius: 0.25rem; cursor: grab; }

        /* --- Seat Grid & Seats --- */
        #seatGridContainer {
            background-color: var(--color-white);
            padding: 1.25rem;
            border-radius: 0.75rem;
            box-shadow: var(--shadow-lg);
        }
        #seatGrid { margin: 0 auto; }
        
        .seat {
            min-height: 105px;
            width: 150px;
            transition: all 0.2s ease-in-out;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            word-break: break-word;
            padding: 6px;
            cursor: grab;
            border-radius: 0.375rem;
            border: 1px solid var(--color-gray-300);
            box-sizing: border-box;
            position: relative;
        }
        .seat.empty { background-color: #F3F4F6; }
        .seat.empty .seat-name { color: var(--color-gray-500); }
        .seat.occupied { background-color: #DBEAFE; }
        .seat.occupied .seat-name { color: var(--color-blue-800); }

        .seat.color-green { background-color: #A7F3D0; }
        .seat.color-green .seat-name { color: #065F46; }
        .seat.color-yellow { background-color: #FDE68A; }
        .seat.color-yellow .seat-name { color: #92400E; }
        .seat.color-red { background-color: #FECACA; }
        .seat.color-red .seat-name { color: #991B1B; }

        /* BENUTZERDEFINIERTE GRUPPENFARBEN */
        .seat.group-fill-0, .color-swatch.group-fill-0 { background-color: #ff0000 !important; }
        .seat.group-fill-0 .seat-name { color: #FFFFFF !important; }
        .seat.group-fill-1, .color-swatch.group-fill-1 { background-color: #2A1AFF !important; }
        .seat.group-fill-1 .seat-name { color: #FFFFFF !important; }
        .seat.group-fill-2, .color-swatch.group-fill-2 { background-color: #faff00 !important; }
        .seat.group-fill-2 .seat-name { color: #000000 !important; }
        .seat.group-fill-3, .color-swatch.group-fill-3 { background-color: #00ff0a !important; }
        .seat.group-fill-3 .seat-name { color: #000000 !important; }
        .seat.group-fill-4, .color-swatch.group-fill-4 { background-color: #ff0099 !important; }
        .seat.group-fill-4 .seat-name { color: #FFFFFF !important; }
        .seat.group-fill-5, .color-swatch.group-fill-5 { background-color: #8D1AFF !important; }
        .seat.group-fill-5 .seat-name { color: #FFFFFF !important; }
        .seat.group-fill-6, .color-swatch.group-fill-6 { background-color: #00ffe0 !important; }
        .seat.group-fill-6 .seat-name { color: #000000 !important; }
        .seat.group-fill-7, .color-swatch.group-fill-7 { background-color: #c97700 !important; }
        .seat.group-fill-7 .seat-name { color: #FFFFFF !important; }
        .seat.group-fill-8, .color-swatch.group-fill-8 { background-color: #006d17 !important; }
        .seat.group-fill-8 .seat-name { color: #FFFFFF !important; }
        .seat.group-fill-9, .color-swatch.group-fill-9 { background-color: #8d8d8d !important; }
        .seat.group-fill-9 .seat-name { color: #FFFFFF !important; }

        .seat.group-stripes-0, .color-swatch.group-stripes-0 { background-image: linear-gradient(45deg, #ff0000 25%, #ffcccc 25%, #ffcccc 50%, #ff0000 50%, #ff0000 75%, #ffcccc 75%, #ffcccc 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-0 .seat-name { color: #000000 !important; }
        .seat.group-stripes-1, .color-swatch.group-stripes-1 { background-image: linear-gradient(45deg, #2A1AFF 25%, #998EFF 25%, #998EFF 50%, #2A1AFF 50%, #2A1AFF 75%, #998EFF 75%, #998EFF 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-1 .seat-name { color: #FFFFFF !important; }
        .seat.group-stripes-2, .color-swatch.group-stripes-2 { background-image: linear-gradient(45deg, #faff00 25%, #ffffcc 25%, #ffffcc 50%, #faff00 50%, #faff00 75%, #ffffcc 75%, #ffffcc 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-2 .seat-name { color: #000000 !important; }
        .seat.group-stripes-3, .color-swatch.group-stripes-3 { background-image: linear-gradient(45deg, #00ff0a 25%, #ccffcc 25%, #ccffcc 50%, #00ff0a 50%, #00ff0a 75%, #ccffcc 75%, #ccffcc 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-3 .seat-name { color: #000000 !important; }
        .seat.group-stripes-4, .color-swatch.group-stripes-4 { background-image: linear-gradient(45deg, #ff0099 25%, #ffccee 25%, #ffccee 50%, #ff0099 50%, #ff0099 75%, #ffccee 75%, #ffccee 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-4 .seat-name { color: #000000 !important; }
        .seat.group-stripes-5, .color-swatch.group-stripes-5 { background-image: linear-gradient(45deg, #8D1AFF 25%, #C68EFF 25%, #C68EFF 50%, #8D1AFF 50%, #8D1AFF 75%, #C68EFF 75%, #C68EFF 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-5 .seat-name { color: #FFFFFF !important; }
        .seat.group-stripes-6, .color-swatch.group-stripes-6 { background-image: linear-gradient(45deg, #00ffe0 25%, #ccfff5 25%, #ccfff5 50%, #00ffe0 50%, #00ffe0 75%, #ccfff5 75%, #ccfff5 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-6 .seat-name { color: #000000 !important; }
        .seat.group-stripes-7, .color-swatch.group-stripes-7 { background-image: linear-gradient(45deg, #c97700 25%, #ffe7cc 25%, #ffe7cc 50%, #c97700 50%, #c97700 75%, #ffe7cc 75%, #ffe7cc 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-7 .seat-name { color: #000000 !important; }
        .seat.group-stripes-8, .color-swatch.group-stripes-8 { background-image: linear-gradient(45deg, #005712 25%, #a3d9a5 25%, #a3d9a5 50%, #005712 50%, #005712 75%, #a3d9a5 75%, #a3d9a5 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-8 .seat-name { color: #FFFFFF !important; }
        .seat.group-stripes-9, .color-swatch.group-stripes-9 { background-image: linear-gradient(45deg, #8d8d8d 25%, #d9d9d9 25%, #d9d9d9 50%, #8d8d8d 50%, #8d8d8d 75%, #d9d9d9 75%, #d9d9d9 100%) !important; background-size: 28px 28px; }
        .seat.group-stripes-9 .seat-name { color: #000000 !important; }

        .seat.keep-empty-selected { border: 3px solid #F97316 !important; box-shadow: 0 0 0 3px rgba(249, 115, 22, 0.5); }
        .seat-name { font-weight: bold; font-size: 1.1rem; margin-top: 6px; line-height: 1.2; }
        .seat.dragging { opacity: 0.5; border: 3px dashed var(--color-blue-500); cursor: grabbing; }
        .seat.drag-over-target { background-color: #E0E7FF; }
        .seat.random-highlight-animation { outline: 3px dashed #FBBF24; outline-offset: 2px; transition: none; }
        .seat.random-selected-final { border: 4px solid #10B981 !important; box-shadow: 0 0 8px rgba(16, 185, 129, 0.6) !important; }

        #teacherDeskContainer { margin-top: 2rem; display: flex; justify-content: center; }
        #teacherDesk {
            background-color: #CBD5E1; padding: 1rem; border-radius: 0.5rem; text-align: center;
            color: #334155; font-weight: 600;
            width: 280px; min-height: 60px;
            display: flex; align-items: center; justify-content: center;
            border: 1px solid #94A3B8; font-size: 1.1rem;
            margin-top: 2rem;
        }

        /* Custom Layout Grid */
        .custom-layout-active-grid { display: grid; gap: 4px; padding: 5px; border: 1px solid #E5E7EB; }
        .custom-layout-active-grid .seat { min-height: 60px; width: 100%; font-size: 0.9em; padding: 3px; }
        .custom-layout-active-grid .seat-name { font-size: 0.7rem; margin-top: 2px; overflow-wrap: break-word; word-break: break-word; line-height: 1.15; }
        .editor-placeholder-cell { width: 100%; padding-bottom: 100%; background-color: #F9FAFB; border: 1px dotted #E5E7EB; box-sizing: border-box; }
        
        /* Default Layout Grid */
        .default-layout { display: flex; flex-direction: column; align-items: center; gap: 1rem; max-width: 1400px; }
        .seat-row-container { width: 100%; display: flex; flex-direction: row; flex-wrap: nowrap; justify-content: center; align-items: flex-start; gap: 5rem; }
        .half-row { display: flex; flex-direction: row; gap: 1rem; }
        .pair-div { display: flex; flex-direction: row; gap: 0.375rem; }

        /* --- Hilfsklassen --- */
        .hidden { display: none !important; }

        /* --- Media Queries für Responsivität --- */
        @media (max-width: 1400px) {
            .default-layout .seat { width: 125px; min-height: 90px; }
            .default-layout .seat-name { font-size: 1rem; }
            #teacherDesk { width: 270px; min-height: 58px; }
            .default-layout #teacherDesk { width: 260px; min-height: 55px; }
        }
        @media (max-width: 1100px) {
            .default-layout .seat { width: 100px; min-height: 75px; }
            .default-layout .seat-name { font-size: 0.9rem; }
            .default-layout #teacherDesk { width: 240px; min-height: 50px; }
            .seat-row-container { gap: 2.5rem !important; }
        }
        @media (max-width: 900px) {
            .default-layout .seat { width: 85px; min-height: 65px; }
            .default-layout .seat-name { font-size: 0.8rem; }
            .default-layout #teacherDesk { width: 220px; min-height: 45px; }
            .seat-row-container { gap: 2rem !important; }
        }
        @media (max-width: 700px) {
            .default-layout .seat { width: 18vw; min-height: 12vw; }
            .default-layout .seat-name { font-size: 1.8vw; }
            .default-layout #teacherDesk { width: 60vw; min-height: 10vw; }
            .seat-row-container { flex-direction: column !important; align-items: center; gap: 0.75rem !important; }
            .half-row { justify-content: center; gap: 0.25rem !important; }
            #roomEditorGrid { max-width: 90vw; }
            .custom-layout-active-grid .seat-name { font-size: 0.6rem; }
            .color-swatch { width: 35px; height: 35px; }
        }
    </style>
</head>
<body>
    <div id="bannerOuterContainer">
        <div id="bannerContainer">
            <img id="bannerImage" src="banner_sitzplan.jpg" alt="Sitzplanheld Banner">
        </div>
    </div>

    <div class="container">
        <div id="tabBar">
            <!-- Tabs werden hier dynamisch von JS eingefügt -->
            <button id="addTabButton" title="Neuen Plan hinzufügen">+</button>
        </div>

        <div class="controls">
            <div class="controls-grid">
                <div>
                    <label for="classNameInput" class="input-label">Klasse:</label>
                    <input type="text" id="classNameInput" class="input-field" placeholder="z.B. 6a">
                </div>
                <div>
                    <label for="roomNameInput" class="input-label">Raum:</label>
                    <input type="text" id="roomNameInput" class="input-field" placeholder="z.B. Raum 101">
                </div>
                <div>
                    <label for="commentInput" class="input-label">Kommentar:</label>
                    <input type="text" id="commentInput" class="input-field" placeholder="z.B. Sitzordnung für Test">
                </div>
            </div>
            <div>
                <label for="studentNames" class="input-label">Schülernamen (mit Komma oder mit Umbruch getrennt, z.B. Max1, Erika1, Tom*, gleiche Zahlen sitzen nebeneinander, Namen mit * sitzen nicht nebeneinander!):</label>
                <textarea id="studentNames" rows="3" class="textarea-field" placeholder="Max Mustermann1, Erika Mustermann1, Tom Tester*, ..."></textarea>
            </div>
            <div class="buttons-container">
                <button id="toggleRoomEditorButton" class="control-button-large">
                    <span class="text" data-text-content>Raumeditor</span>
                </button>
                <button id="assignAllButton" class="control-button-large">
                    <span class="text" data-text-content>Zuweisen</span>
                </button>
                <button id="generateGroupsButton" class="control-button-large">
                    <span class="text" data-text-content>Gruppen</span>
                </button>
                <button id="randomSelectButton" class="control-button-large">
                    <span class="text" data-text-content>Zufall</span>
                </button>
                <button id="copyPlanButton" class="control-button-large hidden">
                    <span class="text" data-text-content>Plan kopieren</span>
                </button>
            </div>
            <div class="buttons-container small-margin">
                <button id="insertTestClassButton" class="control-button-small">
                    <span class="text">Testklasse</span>
                </button>
                <button id="savePlanButton" class="control-button-small">
                    <span class="text" data-text-content>Speichern</span>
                </button>
                <button id="loadPlanButton" class="control-button-small">
                    <span class="text" data-text-content>Laden</span>
                </button>
                <input type="file" id="loadFileInput" accept=".json" class="hidden">
                <button id="downloadPdfButton" class="control-button-small">
                    <span class="text" data-text-content>PDF</span>
                </button>
            </div>
            <div id="messageArea"></div>
        </div>

        <!-- KORREKTUR: Die 'hidden' Klasse wird standardmäßig hinzugefügt, um den Zustand klar zu definieren -->
        <div id="roomEditorContainer" class="editor-panel hidden">
            <h3 class="editor-title">Raumeditor</h3>
            <p class="editor-description">Klicke auf die Kästchen, um Sitzplätze für den Plan auszuwählen (6 Reihen, 9 Spalten).</p>
            <div id="roomEditorGrid"></div>
            <div class="editor-button-container">
                <button id="applyLayoutButton" class="editor-button">Layout anwenden</button>
            </div>
        </div>

        <div id="groupEditorContainer" class="editor-panel hidden">
            <h3 class="editor-title">Gruppen-Editor</h3>
            <div class="mb-4">
                <label for="groupEditorInput" class="input-label">Zufällige Gruppeneinteilung:</label>
                <input type="text" id="groupEditorInput" class="input-field" placeholder="Anzahl (z.B. 4) oder Größe (z.B. G3)">
                <button id="generateRandomGroupsButton" class="editor-button">Zufällige Gruppen bilden</button>
            </div>
            <p class="editor-description">Oder ziehe eine Gruppenfarbe auf einen Sitzplatz:</p>
            <div id="groupEditorColorSwatches"></div>
            <div class="editor-button-container">
                <button id="closeGroupEditorButton" class="editor-button">Editor schließen</button>
            </div>
        </div>

        <div id="seatGridContainer">
            <div id="seatGrid"></div>
            <div id="teacherDeskContainer">
                <div id="teacherDesk">Pult</div>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
    
            let jsPDF;
            if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                console.error("jsPDF library not found. PDF export will be disabled.");
                const downloadPdfButton = document.getElementById('downloadPdfButton');
                if(downloadPdfButton) {
                    downloadPdfButton.disabled = true;
                    downloadPdfButton.title = "PDF-Bibliothek nicht geladen.";
                    downloadPdfButton.style.opacity = "0.5";
                    downloadPdfButton.style.cursor = "not-allowed";
                }
            } else {
                jsPDF = window.jspdf.jsPDF;
            }

            const DEFAULT_NUM_SEATS = 32;
            const DEFAULT_SEATS_PER_ROW = 8;
            const DEFAULT_SEATS_PER_PAIR = 2;
            const DEFAULT_PAIRS_PER_ROW = DEFAULT_SEATS_PER_ROW / DEFAULT_SEATS_PER_PAIR;
            const GROUP_COLORS_COUNT = 10;
            const EDITOR_ROWS = 6;
            const EDITOR_COLS = 9;
            const EDITOR_CELL_COUNT = EDITOR_ROWS * EDITOR_COLS;

            let plans = [];
            let activePlanId = null;

            let draggedSeatIndex = null;
            let draggedGroupInfo = null;
            let randomAnimationTimeoutId = null;
            let currentRandomHighlightIndex = -1;

            const tabBar = document.getElementById('tabBar');
            const addTabButton = document.getElementById('addTabButton');
            const classNameInput = document.getElementById('classNameInput');
            const roomNameInput = document.getElementById('roomNameInput');
            const commentInput = document.getElementById('commentInput');
            const groupEditorInput = document.getElementById('groupEditorInput');
            const studentNamesTextarea = document.getElementById('studentNames');
            const assignAllButton = document.getElementById('assignAllButton');
            const generateGroupsButton = document.getElementById('generateGroupsButton');
            const generateRandomGroupsButton = document.getElementById('generateRandomGroupsButton');
            const randomSelectButton = document.getElementById('randomSelectButton');
            const insertTestClassButton = document.getElementById('insertTestClassButton');
            const toggleRoomEditorButton = document.getElementById('toggleRoomEditorButton');
            const roomEditorContainer = document.getElementById('roomEditorContainer');
            const roomEditorGridDiv = document.getElementById('roomEditorGrid');
            const applyLayoutButton = document.getElementById('applyLayoutButton');
            const copyPlanButton = document.getElementById('copyPlanButton');
            const groupEditorContainer = document.getElementById('groupEditorContainer');
            const groupEditorColorSwatchesDiv = document.getElementById('groupEditorColorSwatches');
            const closeGroupEditorButton = document.getElementById('closeGroupEditorButton');
            const savePlanButton = document.getElementById('savePlanButton');
            const loadPlanButton = document.getElementById('loadPlanButton');
            const loadFileInput = document.getElementById('loadFileInput');
            const downloadPdfButton = document.getElementById('downloadPdfButton');
            const seatGridDiv = document.getElementById('seatGrid');
            const messageArea = document.getElementById('messageArea');

            const PREDEFINED_DEFAULT_LAYOUT_SEAT_DEFINITIONS = [];
            for (let r = 0; r < 4; r++) { // 4 rows
                for (let c = 0; c < 4; c++) { // First block of 4 columns
                    PREDEFINED_DEFAULT_LAYOUT_SEAT_DEFINITIONS.push({ gridIndex: (r * EDITOR_COLS) + c });
                }
                for (let c = 5; c < 9; c++) { // Second block of 4 columns (cols 5,6,7,8 in editor)
                    PREDEFINED_DEFAULT_LAYOUT_SEAT_DEFINITIONS.push({ gridIndex: (r * EDITOR_COLS) + c });
                }
            }


            // --- Plan- und Tab-Management ---
            function createNewPlan(name = `Plan ${plans.length + 1}`, copyFromPlan = null) {
                const planId = Date.now().toString() + Math.random().toString(36).substring(2,7);
                const newPlan = {
                    planId: planId,
                    planName: name,
                    seatData: [],
                    allParsedStudentsList: copyFromPlan ? JSON.parse(JSON.stringify(copyFromPlan.allParsedStudentsList)) : [],
                    className: copyFromPlan ? copyFromPlan.className : "",
                    roomName: copyFromPlan ? copyFromPlan.roomName : "",
                    comment: copyFromPlan ? copyFromPlan.comment : "",
                    groupSetting: copyFromPlan ? copyFromPlan.groupSetting : "",
                    isCustomLayoutActive: copyFromPlan ? copyFromPlan.isCustomLayoutActive : false,
                    customLayoutSeatDefinitions: copyFromPlan ? JSON.parse(JSON.stringify(copyFromPlan.customLayoutSeatDefinitions)) : [],
                    NUM_SEATS_EFFECTIVE: copyFromPlan ? copyFromPlan.NUM_SEATS_EFFECTIVE : 0,
                    minUsedRow: copyFromPlan ? copyFromPlan.minUsedRow : 0,
                    maxUsedRow: copyFromPlan ? copyFromPlan.maxUsedRow : EDITOR_ROWS - 1,
                    minUsedCol: copyFromPlan ? copyFromPlan.minUsedCol : 0,
                    maxUsedCol: copyFromPlan ? copyFromPlan.maxUsedCol : EDITOR_COLS - 1,
                    areGroupsActive: copyFromPlan ? copyFromPlan.areGroupsActive : false,
                    finalRandomSeatIndex: -1
                };
                if (copyFromPlan && copyFromPlan.isCustomLayoutActive) {
                    calculateUsedBoundsForPlan(newPlan);
                }
                initializeSeatDataForPlan(newPlan);
                return newPlan;
            }

            function initializeSeatDataForPlan(plan) {
                plan.seatData = [];
                for (let i = 0; i < plan.NUM_SEATS_EFFECTIVE; i++) {
                    plan.seatData.push({
                        id: i,
                        originalGridIndex: plan.isCustomLayoutActive ? plan.customLayoutSeatDefinitions[i].gridIndex : null,
                        student: null,
                        isMarkedToKeepEmpty: false,
                        colorState: 0,
                        groupId: null,
                        groupStyleType: null
                    });
                }
            }

            function updateActivePlanDataFromUI() {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (activePlan) {
                    activePlan.className = classNameInput.value.trim();
                    activePlan.roomName = roomNameInput.value.trim();
                    activePlan.comment = commentInput.value.trim();
                    activePlan.groupSetting = groupEditorInput.value.trim();
                    parseStudentNamesAndUpdateActivePlan();
                }
            }


            function addTab() {
                updateActivePlanDataFromUI();
                const activePlanForCopy = plans.find(p => p.planId === activePlanId);
                const newPlan = createNewPlan(undefined, activePlanForCopy);
                plans.push(newPlan);
                setActivePlan(newPlan.planId);
            }

            function setActivePlan(planId) {
                if (activePlanId && activePlanId !== planId) {
                    updateActivePlanDataFromUI();
                }

                activePlanId = planId;
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (activePlan) {
                    classNameInput.value = activePlan.className || "";
                    roomNameInput.value = activePlan.roomName || "";
                    commentInput.value = activePlan.comment || "";
                    groupEditorInput.value = activePlan.groupSetting || "";
                    studentNamesTextarea.value = activePlan.allParsedStudentsList.map(s => s.originalName).join(',\n');

                    const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');
                    if (groupsButtonTextSpan) {
                        groupsButtonTextSpan.textContent = activePlan.areGroupsActive ? "Gr. löschen" : "Gruppen";
                    }

                    const roomEditorButtonTextSpan = toggleRoomEditorButton.querySelector('span[data-text-content]');
                    if (roomEditorButtonTextSpan) {
                        roomEditorButtonTextSpan.textContent = "Raumeditor";
                    }
                    
                    // Ensure both panels are hidden when switching tabs
                    roomEditorContainer.classList.add('hidden');
                    groupEditorContainer.classList.add('hidden');

                    if (plans.length > 1 && plans[0].planId !== activePlanId) {
                        copyPlanButton.classList.remove('hidden');
                        const sourcePlanName = plans[0].planName || "Plan 1";
                        copyPlanButton.querySelector('span[data-text-content]').textContent = `Raumplan '${sourcePlanName.substring(0,10)}...'`;
                    } else {
                        copyPlanButton.classList.add('hidden');
                    }


                    renderTabs();
                    renderGridForActivePlan();
                }
            }

            function renderTabs() {
                // Clear all but the add button
                while (tabBar.firstChild && tabBar.firstChild.id !== 'addTabButton') {
                    tabBar.removeChild(tabBar.firstChild);
                }

                plans.forEach(plan => {
                    const tabDiv = document.createElement('div');
                    tabDiv.classList.add('tab');
                    if (plan.planId === activePlanId) {
                        tabDiv.classList.add('active');
                    }
                    tabDiv.dataset.planId = plan.planId;

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = plan.planName;
                    nameSpan.title = "Klicken zum Umbenennen";
                    nameSpan.classList.add('tab-name-display');
                    tabDiv.appendChild(nameSpan);

                    const editIcon = document.createElement('span');
                    editIcon.classList.add('tab-action-icon');
                    editIcon.innerHTML = '✎';
                    editIcon.title = "Tab umbenennen";
                    editIcon.addEventListener('click', (e) => {
                        e.stopPropagation();
                        makeTabNameEditable(nameSpan, plan.planId);
                    });
                    tabDiv.appendChild(editIcon);


                    const closeButton = document.createElement('span');
                    closeButton.classList.add('tab-action-icon');
                    closeButton.innerHTML = '&times;';
                    closeButton.title = "Tab schließen";
                    closeButton.addEventListener('click', (e) => {
                        e.stopPropagation();
                        closeTab(plan.planId);
                    });
                    tabDiv.appendChild(closeButton);

                    tabDiv.addEventListener('click', () => setActivePlan(plan.planId));
                    tabBar.insertBefore(tabDiv, addTabButton);
                });
            }

            function makeTabNameEditable(spanElement, planId) {
                const originalName = spanElement.textContent;
                const input = document.createElement('input');
                input.type = 'text';
                input.value = originalName;
                input.classList.add('tab-input');

                spanElement.style.display = 'none';
                spanElement.parentNode.insertBefore(input, spanElement.nextSibling);
                input.focus();
                input.select();

                let finishedEditing = false;

                const finishEdit = (saveChanges) => {
                    if (finishedEditing) return;
                    finishedEditing = true;

                    let newName = originalName;
                    if (saveChanges) {
                        newName = input.value.trim() || `Plan ${plans.findIndex(p => p.planId === planId) + 1}`;
                    }

                    const plan = plans.find(p => p.planId === planId);
                    if (plan) {
                        plan.planName = newName;
                    }
                    spanElement.textContent = newName;
                    spanElement.style.display = '';
                    if (input.parentNode) {
                        input.remove();
                    }
                    input.removeEventListener('blur', handleBlur);
                    input.removeEventListener('keydown', handleKeydown);
                };

                const handleBlur = () => {
                    setTimeout(() => {
                        if (document.body.contains(input)) {
                            finishEdit(true);
                        }
                    }, 50);
                };

                const handleKeydown = (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        finishEdit(true);
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        finishEdit(false);
                    }
                };

                input.addEventListener('blur', handleBlur);
                input.addEventListener('keydown', handleKeydown);
            }


            function closeTab(planIdToClose) {
                if (plans.length <= 1) {
                    messageArea.textContent = "Der letzte Tab kann nicht geschlossen werden.";
                    return;
                }
                const planIndex = plans.findIndex(p => p.planId === planIdToClose);
                if (planIndex > -1) {
                    plans.splice(planIndex, 1);
                    if (activePlanId === planIdToClose) {
                        setActivePlan(plans[0].planId);
                    } else {
                        renderTabs();
                    }
                }
            }


            // --- Raumeditor Logik ---
            function createRoomEditorGrid() {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                roomEditorGridDiv.innerHTML = '';
                roomEditorGridDiv.style.gridTemplateColumns = `repeat(${EDITOR_COLS}, 1fr)`;
                for (let i = 0; i < EDITOR_CELL_COUNT; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add('editor-cell');
                    cell.dataset.gridIndex = i;
                    if (activePlan.customLayoutSeatDefinitions.some(def => def.gridIndex === i)) {
                        cell.classList.add('selected');
                    }
                    cell.addEventListener('click', handleEditorCellClick);
                    roomEditorGridDiv.appendChild(cell);
                }
            }

            function handleEditorCellClick(event) {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                const gridIndex = parseInt(event.currentTarget.dataset.gridIndex);
                const selectedIndex = activePlan.customLayoutSeatDefinitions.findIndex(def => def.gridIndex === gridIndex);

                if (selectedIndex > -1) {
                    activePlan.customLayoutSeatDefinitions.splice(selectedIndex, 1);
                    event.currentTarget.classList.remove('selected');
                } else {
                    activePlan.customLayoutSeatDefinitions.push({ gridIndex: gridIndex });
                    event.currentTarget.classList.add('selected');
                }
            }

            // KORREKTUR: Vereinfachte Logik zum Umschalten der Sichtbarkeit
            toggleRoomEditorButton.addEventListener('click', () => {
                // Zuerst das andere Panel sicher ausblenden
                groupEditorContainer.classList.add('hidden');
                
                // Den Text des anderen Buttons zurücksetzen
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (activePlan) {
                    generateGroupsButton.querySelector('span[data-text-content]').textContent = activePlan.areGroupsActive ? "Gr. löschen" : "Gruppen";
                }

                // Die Sichtbarkeit des Raumeditors umschalten
                roomEditorContainer.classList.toggle('hidden');

                // Button-Text basierend auf dem neuen Zustand aktualisieren
                const roomEditorButtonTextSpan = toggleRoomEditorButton.querySelector('span[data-text-content]');
                if (roomEditorContainer.classList.contains('hidden')) {
                    roomEditorButtonTextSpan.textContent = "Raumeditor";
                } else {
                    createRoomEditorGrid();
                    roomEditorButtonTextSpan.textContent = "Editor aus";
                }
            });

            function calculateUsedBoundsForPlan(plan) {
                if (!plan.isCustomLayoutActive || plan.customLayoutSeatDefinitions.length === 0) {
                    plan.minUsedRow = 0; plan.maxUsedRow = EDITOR_ROWS - 1;
                    plan.minUsedCol = 0; plan.maxUsedCol = EDITOR_COLS - 1;
                    return;
                }
                plan.minUsedRow = EDITOR_ROWS; plan.maxUsedRow = -1;
                plan.minUsedCol = EDITOR_COLS; plan.maxUsedCol = -1;

                plan.customLayoutSeatDefinitions.forEach(def => {
                    const r = Math.floor(def.gridIndex / EDITOR_COLS);
                    const c = def.gridIndex % EDITOR_COLS;
                    if (r < plan.minUsedRow) plan.minUsedRow = r;
                    if (r > plan.maxUsedRow) plan.maxUsedRow = r;
                    if (c < plan.minUsedCol) plan.minUsedCol = c;
                    if (c > plan.maxUsedCol) plan.maxUsedCol = c;
                });
                if (plan.minUsedRow > plan.maxUsedRow) { plan.minUsedRow = 0; plan.maxUsedRow = 0; }
                if (plan.minUsedCol > plan.maxUsedCol) { plan.minUsedCol = 0; plan.maxUsedCol = 0; }
            }


            applyLayoutButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                if (activePlan.customLayoutSeatDefinitions.length === 0) {
                    activePlan.isCustomLayoutActive = false;
                    activePlan.NUM_SEATS_EFFECTIVE = 0;
                    messageArea.textContent = "Keine Plätze im Editor ausgewählt. Layout nicht geändert.";
                } else {
                    activePlan.isCustomLayoutActive = true;
                    activePlan.NUM_SEATS_EFFECTIVE = activePlan.customLayoutSeatDefinitions.length;
                    activePlan.customLayoutSeatDefinitions.sort((a,b) => a.gridIndex - b.gridIndex);
                    calculateUsedBoundsForPlan(activePlan);
                    messageArea.textContent = `Layout mit ${activePlan.NUM_SEATS_EFFECTIVE} Plätzen angewendet.`;
                }
                initializeSeatDataForPlan(activePlan);
                renderGridForActivePlan();
                roomEditorContainer.classList.add('hidden');
                toggleRoomEditorButton.querySelector('span[data-text-content]').textContent = "Raumeditor";
            });

            function renderGridForActivePlan() {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (activePlan) {
                    renderGrid(activePlan);
                } else if (plans.length > 0) {
                    setActivePlan(plans[0].planId);
                } else {
                    seatGridDiv.innerHTML = '<p style="text-align: center; color: #6B7280; grid-column: 1 / -1; padding: 2.5rem 0;">Erstelle zuerst einen Raumplan mit dem Raumeditor oder lade einen bestehenden Plan!</p>';
                    seatGridDiv.className = 'custom-layout-active-grid';
                    seatGridDiv.style.gridTemplateColumns = '1fr';
                    seatGridDiv.style.maxWidth = '600px';
                    seatGridDiv.style.margin = '0 auto';
                }
            }

            function renderGrid(plan) {
                messageArea.textContent = '';
                seatGridDiv.innerHTML = '';

                if (plan.NUM_SEATS_EFFECTIVE === 0 && !plan.isCustomLayoutActive) {
                    seatGridDiv.innerHTML = '<p style="text-align: center; color: #6B7280; grid-column: 1 / -1; padding: 2.5rem 0;">Erstelle zuerst einen Raumplan mit dem Raumeditor oder lade einen bestehenden Plan!</p>';
                    seatGridDiv.className = 'custom-layout-active-grid';
                    seatGridDiv.style.gridTemplateColumns = '1fr';
                    seatGridDiv.style.maxWidth = '600px';
                    seatGridDiv.style.margin = '0 auto';
                    return;
                }

                if (plan.isCustomLayoutActive) {
                    seatGridDiv.className = 'custom-layout-active-grid';
                    const numActiveCols = (plan.maxUsedCol - plan.minUsedCol + 1);
                    seatGridDiv.style.gridTemplateColumns = `repeat(${numActiveCols}, 1fr)`;

                    const desiredSeatWidthInCustomGrid = 85;
                    const gapBetweenSeats = 4;
                    seatGridDiv.style.maxWidth = `${numActiveCols * desiredSeatWidthInCustomGrid + (numActiveCols > 1 ? (numActiveCols - 1) * gapBetweenSeats : 0)}px`;
                    seatGridDiv.style.margin = '0 auto';


                    for (let r = plan.minUsedRow; r <= plan.maxUsedRow; r++) {
                        for (let c = plan.minUsedCol; c <= plan.maxUsedCol; c++) {
                            const editorGridIdx = r * EDITOR_COLS + c;
                            const seatInfoForThisCell = plan.seatData.find(sd => sd.originalGridIndex === editorGridIdx);

                            if (seatInfoForThisCell) {
                                const seatDataIndex = plan.seatData.indexOf(seatInfoForThisCell);
                                const seatDiv = createSeatElement(seatInfoForThisCell, seatDataIndex, plan);
                                seatGridDiv.appendChild(seatDiv);
                            } else {
                                const placeholderCell = document.createElement('div');
                                placeholderCell.classList.add('editor-placeholder-cell');
                                seatGridDiv.appendChild(placeholderCell);
                            }
                        }
                    }
                } else if (plan.NUM_SEATS_EFFECTIVE > 0) {
                    seatGridDiv.className = 'default-layout';
                    seatGridDiv.style.maxWidth = '1400px';
                    seatGridDiv.style.margin = '';


                    const defaultLayoutSeatElements = [];
                    plan.seatData.forEach((seatInfo, index) => {
                        const seatDiv = createSeatElement(seatInfo, index, plan);
                        defaultLayoutSeatElements.push(seatDiv);
                    });


                    for (let r = 0; r < DEFAULT_NUM_SEATS / DEFAULT_SEATS_PER_ROW; r++) {
                        const rowContainerDiv = document.createElement('div');
                        rowContainerDiv.className = 'seat-row-container';

                        const leftHalfDiv = document.createElement('div');
                        leftHalfDiv.className = 'half-row';

                        const rightHalfDiv = document.createElement('div');
                        rightHalfDiv.className = 'half-row';

                        for (let p = 0; p < DEFAULT_PAIRS_PER_ROW; p++) {
                            const pairDiv = document.createElement('div');
                            pairDiv.className = 'pair-div';

                            const seat1IndexInDefaultLayout = r * DEFAULT_SEATS_PER_ROW + p * DEFAULT_SEATS_PER_PAIR;
                            const seat2IndexInDefaultLayout = seat1IndexInDefaultLayout + 1;

                            if (defaultLayoutSeatElements[seat1IndexInDefaultLayout]) pairDiv.appendChild(defaultLayoutSeatElements[seat1IndexInDefaultLayout]);
                            if (defaultLayoutSeatElements[seat2IndexInDefaultLayout]) pairDiv.appendChild(defaultLayoutSeatElements[seat2IndexInDefaultLayout]);

                            if (p < DEFAULT_PAIRS_PER_ROW / 2) {
                                leftHalfDiv.appendChild(pairDiv);
                            } else {
                                rightHalfDiv.appendChild(pairDiv);
                            }
                        }
                        rowContainerDiv.appendChild(leftHalfDiv);
                        rowContainerDiv.appendChild(rightHalfDiv);
                        seatGridDiv.appendChild(rowContainerDiv);
                    }
                }
            }

            function createSeatElement(seatInfo, index, plan) {
                const seatDiv = document.createElement('div');
                seatDiv.id = `seat-${index}`;
                seatDiv.dataset.index = index;
                seatDiv.classList.add('seat');

                seatDiv.classList.remove('occupied', 'empty', 'color-green', 'color-yellow', 'color-red', 'random-selected-final', 'random-highlight-animation');
                for (let k = 0; k < GROUP_COLORS_COUNT; k++) {
                    seatDiv.classList.remove(`group-fill-${k}`);
                    seatDiv.classList.remove(`group-stripes-${k}`);
                }

                if (seatInfo.groupId !== null) {
                    const colorIndex = seatInfo.groupId % GROUP_COLORS_COUNT;
                    if (seatInfo.groupStyleType === 'stripes') {
                        seatDiv.classList.add(`group-stripes-${colorIndex}`);
                    } else {
                        seatDiv.classList.add(`group-fill-${colorIndex}`);
                    }
                } else if (seatInfo.colorState === 1) { seatDiv.classList.add('color-green'); }
                else if (seatInfo.colorState === 2) { seatDiv.classList.add('color-yellow'); }
                else if (seatInfo.colorState === 3) { seatDiv.classList.add('color-red'); }
                else { if (seatInfo.student) { seatDiv.classList.add('occupied'); } else { seatDiv.classList.add('empty'); } }


                if (seatInfo.student) {
                    const studentObject = plan.allParsedStudentsList.find(s => s.originalName === seatInfo.student);
                    let displayName = studentObject ? studentObject.displayName : seatInfo.student.replace(/[\d*]+$/, '').trim();
                    const firstSpace = displayName.indexOf(' ');
                    if (firstSpace > 0 && displayName.substring(firstSpace + 1).trim() !== "") {
                        displayName = displayName.substring(0, firstSpace) + "<br>" + displayName.substring(firstSpace + 1);
                    }
                    seatDiv.innerHTML = `<span class="seat-name">${displayName}</span>`;
                    seatDiv.draggable = true;
                } else {
                    seatDiv.innerHTML = `<span class="seat-name">Frei</span>`;
                    seatDiv.draggable = false;
                }

                if (seatInfo.isMarkedToKeepEmpty) { seatDiv.classList.add('keep-empty-selected'); }
                else { seatDiv.classList.remove('keep-empty-selected'); }

                if (index === plan.finalRandomSeatIndex) { seatDiv.classList.add('random-selected-final'); }

                seatDiv.addEventListener('click', handleSeatClick);
                seatDiv.addEventListener('contextmenu', handleSeatRightClick);
                seatDiv.addEventListener('dragstart', handleDragStart);
                seatDiv.addEventListener('dragend', handleDragEnd);
                seatDiv.addEventListener('dragover', handleDragOver);
                seatDiv.addEventListener('dragenter', handleDragEnter);
                seatDiv.addEventListener('dragleave', handleDragLeave);
                seatDiv.addEventListener('drop', handleGroupDrop);
                return seatDiv;
            }

            function handleSeatClick(event) {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;
                const seatIndex = parseInt(event.currentTarget.dataset.index);
                activePlan.seatData[seatIndex].isMarkedToKeepEmpty = !activePlan.seatData[seatIndex].isMarkedToKeepEmpty;
                renderGridForActivePlan();
            }

            function handleSeatRightClick(event) {
                event.preventDefault();
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;
                const seatIndex = parseInt(event.currentTarget.dataset.index);
                activePlan.seatData[seatIndex].colorState = (activePlan.seatData[seatIndex].colorState + 1) % 4;
                activePlan.seatData[seatIndex].groupId = null;
                activePlan.seatData[seatIndex].groupStyleType = null;
                renderGridForActivePlan();
            }


            function handleDragStart(event) {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                if (event.currentTarget.classList.contains('color-swatch')) {
                    draggedGroupInfo = {
                        groupId: parseInt(event.currentTarget.dataset.groupId),
                        groupStyleType: event.currentTarget.dataset.groupStyleType
                    };
                    event.dataTransfer.setData('text/plain', 'group-swatch');
                } else if (event.currentTarget.classList.contains('seat')) {
                    const seatIndex = parseInt(event.currentTarget.dataset.index);
                    if (!activePlan.seatData[seatIndex].student) {
                        event.preventDefault();
                        return;
                    }
                    draggedSeatIndex = seatIndex;
                    event.dataTransfer.setData('text/plain', seatIndex.toString());
                }
                if(event.currentTarget.classList.contains('seat')) event.currentTarget.classList.add('dragging');
            }

            function handleDragEnd(event) {
                if(event.currentTarget.classList.contains('seat')) event.currentTarget.classList.remove('dragging');
                document.querySelectorAll('.seat.drag-over-target').forEach(seat => {
                    seat.classList.remove('drag-over-target');
                });
                draggedSeatIndex = null;
                draggedGroupInfo = null;
            }

            function handleDragOver(event) {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }

            function handleDragEnter(event) {
                event.preventDefault();
                if (event.currentTarget.classList.contains('seat')) {
                    event.currentTarget.classList.add('drag-over-target');
                }
            }

            function handleDragLeave(event) {
                if (event.currentTarget.classList.contains('seat')) {
                    event.currentTarget.classList.remove('drag-over-target');
                }
            }

            function handleGroupDrop(event) {
                event.preventDefault();
                event.currentTarget.classList.remove('drag-over-target');
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;
                const targetSeatIndex = parseInt(event.currentTarget.dataset.index);

                if (draggedGroupInfo) {
                    activePlan.seatData[targetSeatIndex].groupId = draggedGroupInfo.groupId;
                    activePlan.seatData[targetSeatIndex].groupStyleType = draggedGroupInfo.groupStyleType;
                    activePlan.seatData[targetSeatIndex].colorState = 0;
                    activePlan.areGroupsActive = true;
                    const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');
                    if (groupsButtonTextSpan) {
                        groupsButtonTextSpan.textContent = "Gr. löschen";
                    }
                } else if (draggedSeatIndex !== null) {
                    if (draggedSeatIndex === targetSeatIndex) {
                        draggedSeatIndex = null;
                        return;
                    }
                    const studentToMove = activePlan.seatData[draggedSeatIndex].student;
                    const studentAtTarget = activePlan.seatData[targetSeatIndex].student;

                    activePlan.seatData[targetSeatIndex].student = studentToMove;
                    activePlan.seatData[draggedSeatIndex].student = studentAtTarget;

                    activePlan.seatData[targetSeatIndex].isMarkedToKeepEmpty = false;
                    activePlan.seatData[targetSeatIndex].groupId = null;
                    activePlan.seatData[targetSeatIndex].groupStyleType = null;
                    activePlan.seatData[targetSeatIndex].colorState = 0;
                    activePlan.seatData[draggedSeatIndex].groupId = null;
                    activePlan.seatData[draggedSeatIndex].groupStyleType = null;
                    activePlan.seatData[draggedSeatIndex].colorState = 0;
                }

                const draggedElement = document.getElementById(`seat-${draggedSeatIndex}`);
                if (draggedElement) draggedElement.classList.remove('dragging');

                draggedSeatIndex = null;
                draggedGroupInfo = null;
                renderGridForActivePlan();
            }

            function parseStudentNamesAndUpdateActivePlan() {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return [];

                const namesStringWithMixedDelimiters = studentNamesTextarea.value.trim();
                if (!namesStringWithMixedDelimiters) {
                    activePlan.allParsedStudentsList = [];
                    return [];
                }

                const namesStringOnlyCommas = namesStringWithMixedDelimiters.replace(/\r\n|\r|\n/g, ',');

                activePlan.allParsedStudentsList = namesStringOnlyCommas.split(',')
                    .map(name => name.trim())
                    .filter(name => name.length > 0)
                    .map(originalName => {
                        let displayName = originalName;
                        let groupKey = null;
                        let isNoNeighbor = false;

                        if (displayName.endsWith('*')) {
                            isNoNeighbor = true;
                            displayName = displayName.slice(0, -1).trim();
                        }
                        const numberMatch = displayName.match(/^(.*?)(\d+)$/);
                        if (numberMatch) {
                            displayName = numberMatch[1].trim();
                            groupKey = numberMatch[2];
                        }
                        return { originalName, displayName, groupKey, isNoNeighbor };
                    });
                return activePlan.allParsedStudentsList;
            }

            function getVisualNeighborIndices(seatIndex, plan) {
                const neighbors = [];
                if (plan.isCustomLayoutActive) {
                    const originalGridIdx = plan.seatData[seatIndex].originalGridIndex;
                    if (originalGridIdx === null) return [];

                    const row = Math.floor(originalGridIdx / EDITOR_COLS);
                    const col = originalGridIdx % EDITOR_COLS;

                    const potentialGridIndices = [
                        (row - 1) * EDITOR_COLS + col,
                        (row + 1) * EDITOR_COLS + col,
                        row * EDITOR_COLS + (col - 1),
                        row * EDITOR_COLS + (col + 1)
                    ];
                    if (col === 0) potentialGridIndices[2] = -1;
                    if (col === EDITOR_COLS - 1) potentialGridIndices[3] = -1;


                    potentialGridIndices.forEach(gridIdx => {
                        if (gridIdx >= 0 && gridIdx < EDITOR_CELL_COUNT) {
                            const neighborSeat = plan.seatData.find(s => s.originalGridIndex === gridIdx);
                            if (neighborSeat) {
                                neighbors.push(plan.seatData.indexOf(neighborSeat));
                            }
                        }
                    });
                    return neighbors;
                }
                const defaultRow = Math.floor(seatIndex / DEFAULT_SEATS_PER_ROW);
                const defaultColInRow = seatIndex % DEFAULT_SEATS_PER_ROW;

                const pairMate = (defaultColInRow % 2 === 0) ? seatIndex + 1 : seatIndex - 1;
                if (pairMate >= defaultRow * DEFAULT_SEATS_PER_ROW && pairMate < (defaultRow + 1) * DEFAULT_SEATS_PER_ROW) {
                    neighbors.push(pairMate);
                }

                if (defaultColInRow === 2) neighbors.push(seatIndex - 1);
                if (defaultColInRow === 6) neighbors.push(seatIndex - 1);
                if (defaultColInRow === 1) neighbors.push(seatIndex + 1);
                if (defaultColInRow === 5) neighbors.push(seatIndex + 1);

                return neighbors.filter(idx => idx >= 0 && idx < plan.NUM_SEATS_EFFECTIVE);
            }

            function canPlaceStudent(studentToPlace, targetSeatIndex, currentPlanState) {
                if (!studentToPlace.isNoNeighbor) {
                    return true;
                }
                const visualNeighbors = getVisualNeighborIndices(targetSeatIndex, currentPlanState);
                for (const neighborIdx of visualNeighbors) {
                    const neighborSeatInfo = currentPlanState.seatData[neighborIdx];
                    if (neighborSeatInfo && neighborSeatInfo.student) {
                        const neighborStudentObject = currentPlanState.allParsedStudentsList.find(s => s.originalName === neighborSeatInfo.student);
                        if (neighborStudentObject && neighborStudentObject.isNoNeighbor) {
                            return false;
                        }
                    }
                }
                return true;
            }

            function generateAssignments(plan, studentsToAssignList, targetSeatIndices) {
                let assignments = {};
                const tempSeatDataForAssignment = JSON.parse(JSON.stringify(plan.seatData));

                targetSeatIndices.forEach(idx => {
                    if (tempSeatDataForAssignment[idx]) tempSeatDataForAssignment[idx].student = null;
                });
                for(let i = 0; i < tempSeatDataForAssignment.length; i++) {
                    if (!targetSeatIndices.includes(i) && plan.seatData[i]) {
                        tempSeatDataForAssignment[i].student = plan.seatData[i].student;
                    }
                }


                let unassignedStudents = 0;
                const studentPool = [...studentsToAssignList];
                const studentPairs = [];
                const individuals = [];

                const groupedByName = {};
                studentPool.forEach(s => {
                    if (s.groupKey) {
                        if (!groupedByName[s.groupKey]) groupedByName[s.groupKey] = [];
                        groupedByName[s.groupKey].push(s);
                    } else {
                        individuals.push(s);
                    }
                });
                for (const key in groupedByName) {
                    while (groupedByName[key].length >= 2) {
                        const s1 = groupedByName[key].shift();
                        const s2 = groupedByName[key].shift();
                        if (s1.isNoNeighbor && s2.isNoNeighbor) {
                            individuals.push(s1, s2);
                        } else {
                            studentPairs.push([s1, s2]);
                        }
                    }
                    individuals.push(...groupedByName[key]);
                }

                studentPairs.sort(() => 0.5 - Math.random());
                let availablePhysicalPairs = [];
                const shuffledTargetIndices = [...targetSeatIndices].sort(() => 0.5 - Math.random());

                if (plan.isCustomLayoutActive) {
                    for(let i=0; i < shuffledTargetIndices.length; i++) {
                        const idx1 = shuffledTargetIndices[i];
                        const originalGridIdx1 = plan.seatData[idx1].originalGridIndex;
                        if (originalGridIdx1 === null) continue;

                        const col1 = originalGridIdx1 % EDITOR_COLS;
                        if (col1 < EDITOR_COLS - 1) {
                            const originalGridIdx2Horizontal = originalGridIdx1 + 1;
                            const idx2 = plan.seatData.findIndex(s => s.originalGridIndex === originalGridIdx2Horizontal);

                            if (idx2 !== -1 && shuffledTargetIndices.includes(idx2) &&
                                tempSeatDataForAssignment[idx1] && tempSeatDataForAssignment[idx1].student === null &&
                                tempSeatDataForAssignment[idx2] && tempSeatDataForAssignment[idx2].student === null) {
                                availablePhysicalPairs.push([idx1, idx2].sort((a,b)=>a-b));
                            }
                        }
                    }
                } else {
                    for(let i=0; i < shuffledTargetIndices.length; i++) {
                        const idx1 = shuffledTargetIndices[i];
                        if (idx1 % 2 === 0 && shuffledTargetIndices.includes(idx1 + 1) &&
                            tempSeatDataForAssignment[idx1] && tempSeatDataForAssignment[idx1].student === null &&
                            tempSeatDataForAssignment[idx1+1] && tempSeatDataForAssignment[idx1+1].student === null) {
                            availablePhysicalPairs.push([idx1, idx1 + 1]);
                        }
                    }
                }
                availablePhysicalPairs = [...new Set(availablePhysicalPairs.map(JSON.stringify))].map(JSON.parse);
                availablePhysicalPairs.sort(() => 0.5 - Math.random());


                studentPairs.forEach(pair => {
                    let placed = false;
                    for (let i = 0; i < availablePhysicalPairs.length; i++) {
                        const [pIdx1, pIdx2] = availablePhysicalPairs[i];
                        if (tempSeatDataForAssignment[pIdx1] && tempSeatDataForAssignment[pIdx1].student === null &&
                            tempSeatDataForAssignment[pIdx2] && tempSeatDataForAssignment[pIdx2].student === null) {
                            if (canPlaceStudent(pair[0], pIdx1, tempSeatDataForAssignment) && canPlaceStudent(pair[1], pIdx2, tempSeatDataForAssignment)) {
                                tempSeatDataForAssignment[pIdx1].student = pair[0].originalName;
                                tempSeatDataForAssignment[pIdx2].student = pair[1].originalName;
                                if (canPlaceStudent(pair[0], pIdx1, tempSeatDataForAssignment) && canPlaceStudent(pair[1], pIdx2, tempSeatDataForAssignment)) {
                                    assignments[pIdx1] = pair[0].originalName;
                                    assignments[pIdx2] = pair[1].originalName;
                                    availablePhysicalPairs.splice(i, 1);
                                    placed = true;
                                    break;
                                } else {
                                    tempSeatDataForAssignment[pIdx1].student = null;
                                    tempSeatDataForAssignment[pIdx2].student = null;
                                }
                            }
                            if (!placed && canPlaceStudent(pair[0], pIdx2, tempSeatDataForAssignment) && canPlaceStudent(pair[1], pIdx1, tempSeatDataForAssignment)) {
                                tempSeatDataForAssignment[pIdx2].student = pair[0].originalName;
                                tempSeatDataForAssignment[pIdx1].student = pair[1].originalName;
                                if (canPlaceStudent(pair[0], pIdx2, tempSeatDataForAssignment) && canPlaceStudent(pair[1], pIdx1, tempSeatDataForAssignment)) {
                                    assignments[pIdx2] = pair[0].originalName;
                                    assignments[pIdx1] = pair[1].originalName;
                                    availablePhysicalPairs.splice(i, 1);
                                    placed = true;
                                    break;
                                } else {
                                    tempSeatDataForAssignment[pIdx1].student = null;
                                    tempSeatDataForAssignment[pIdx2].student = null;
                                }
                            }
                        }
                    }
                    if (!placed) individuals.push(...pair);
                });

                individuals.sort(() => 0.5 - Math.random());
                individuals.sort((a,b) => (b.isNoNeighbor ? 1 : 0) - (a.isNoNeighbor ? 1 : 0));


                let remainingSingleSeats = targetSeatIndices.filter(idx => !assignments[idx]).sort(() => 0.5 - Math.random());

                individuals.forEach(student => {
                    let placed = false;
                    for (let i = 0; i < remainingSingleSeats.length; i++) {
                        const seatIdx = remainingSingleSeats[i];
                        if (tempSeatDataForAssignment[seatIdx] && tempSeatDataForAssignment[seatIdx].student === null && canPlaceStudent(student, seatIdx, tempSeatDataForAssignment)) {
                            assignments[seatIdx] = student.originalName;
                            tempSeatDataForAssignment[seatIdx].student = student.originalName;
                            remainingSingleSeats.splice(i, 1);
                            placed = true;
                            break;
                        }
                    }
                    if (!placed) unassignedStudents++;
                });

                if (unassignedStudents > 0) {
                    messageArea.textContent = `${unassignedStudents} Schüler konnten aufgrund von Regeln oder Platzmangel nicht zugewiesen werden.`;
                }
                return assignments;
            }

            function performFullSeatAssignment(plan) {
                if (plan.finalRandomSeatIndex !== -1) {
                    const prevFinalSeatDiv = document.getElementById(`seat-${plan.finalRandomSeatIndex}`);
                    if (prevFinalSeatDiv) prevFinalSeatDiv.classList.remove('random-selected-final');
                    plan.finalRandomSeatIndex = -1;
                }

                if (plan.NUM_SEATS_EFFECTIVE === 0 && !plan.isCustomLayoutActive) {
                    plan.isCustomLayoutActive = true;
                    plan.NUM_SEATS_EFFECTIVE = DEFAULT_NUM_SEATS;
                    plan.customLayoutSeatDefinitions = [...PREDEFINED_DEFAULT_LAYOUT_SEAT_DEFINITIONS];
                    calculateUsedBoundsForPlan(plan);
                    initializeSeatDataForPlan(plan);
                }

                const parsedStudents = plan.allParsedStudentsList;
                if (parsedStudents.length === 0) {
                    messageArea.textContent = "Bitte Schülernamen für diesen Plan eingeben.";
                    plan.seatData.forEach(seat => {
                        seat.student = null;
                        seat.isMarkedToKeepEmpty = false;
                        seat.colorState = 0;
                        seat.groupId = null;
                        seat.groupStyleType = null;
                    });
                    renderGridForActivePlan();
                    return;
                }

                plan.seatData.forEach(seat => {
                    seat.student = null;
                    seat.colorState = 0;
                    seat.groupId = null;
                    seat.groupStyleType = null;
                });

                const allCurrentLayoutSeatIndices = Array.from({ length: plan.NUM_SEATS_EFFECTIVE }, (_, k) => k);
                const indicesToKeepEmpty = plan.seatData
                    .map((seat, index) => seat.isMarkedToKeepEmpty ? index : -1)
                    .filter(index => index !== -1);

                const targetSeatIndices = allCurrentLayoutSeatIndices.filter(idx => !indicesToKeepEmpty.includes(idx));
                const newAssignments = generateAssignments(plan, parsedStudents, targetSeatIndices);

                for (const seatIndex in newAssignments) {
                    plan.seatData[parseInt(seatIndex)].student = newAssignments[seatIndex];
                }

                plan.seatData.forEach(seat => seat.isMarkedToKeepEmpty = false);
                if (plan.planId === activePlanId) {
                    const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');
                    if (groupsButtonTextSpan) {
                        groupsButtonTextSpan.textContent = "Gruppen";
                    }
                }
                plan.areGroupsActive = false;

                if (plan.planId === activePlanId) {
                    renderGridForActivePlan();
                }
            }


            assignAllButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;
                parseStudentNamesAndUpdateActivePlan();
                performFullSeatAssignment(activePlan);
            });

            copyPlanButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                const sourcePlan = plans[0];
                if (!activePlan || !sourcePlan || activePlan.planId === sourcePlan.planId) return;

                activePlan.className = sourcePlan.className;
                activePlan.roomName = sourcePlan.roomName;
                activePlan.comment = sourcePlan.comment;
                activePlan.groupSetting = sourcePlan.groupSetting;
                activePlan.isCustomLayoutActive = sourcePlan.isCustomLayoutActive;
                activePlan.customLayoutSeatDefinitions = JSON.parse(JSON.stringify(sourcePlan.customLayoutSeatDefinitions));
                activePlan.NUM_SEATS_EFFECTIVE = sourcePlan.NUM_SEATS_EFFECTIVE;

                if (activePlan.isCustomLayoutActive) {
                    calculateUsedBoundsForPlan(activePlan);
                } else {
                    activePlan.minUsedRow = 0; activePlan.maxUsedRow = EDITOR_ROWS - 1;
                    activePlan.minUsedCol = 0; activePlan.maxUsedCol = EDITOR_COLS - 1;
                }

                initializeSeatDataForPlan(activePlan);

                sourcePlan.seatData.forEach((sourceSeat, sourceSeatIndex) => {
                    if (sourceSeat.student) {
                        const studentExistsInActivePlan = activePlan.allParsedStudentsList.find(s => s.originalName === sourceSeat.student);
                        if (studentExistsInActivePlan) {
                            let targetSeatInActivePlan = null;
                            if (activePlan.isCustomLayoutActive) {
                                targetSeatInActivePlan = activePlan.seatData.find(s => s.originalGridIndex === sourceSeat.originalGridIndex);
                            } else {
                                if (sourceSeatIndex < activePlan.seatData.length) {
                                    targetSeatInActivePlan = activePlan.seatData[sourceSeatIndex];
                                }
                            }

                            if (targetSeatInActivePlan) {
                                targetSeatInActivePlan.student = sourceSeat.student;
                                targetSeatInActivePlan.colorState = sourceSeat.colorState;
                                targetSeatInActivePlan.groupId = sourceSeat.groupId;
                                targetSeatInActivePlan.groupStyleType = sourceSeat.groupStyleType;
                                targetSeatInActivePlan.isMarkedToKeepEmpty = sourceSeat.isMarkedToKeepEmpty;
                            }
                        }
                    } else {
                        let targetSeatInActivePlan = null;
                        if (activePlan.isCustomLayoutActive) {
                            targetSeatInActivePlan = activePlan.seatData.find(s => s.originalGridIndex === sourceSeat.originalGridIndex);
                        } else {
                            if (sourceSeatIndex < activePlan.seatData.length) {
                                targetSeatInActivePlan = activePlan.seatData[sourceSeatIndex];
                            }
                        }
                        if (targetSeatInActivePlan) {
                            targetSeatInActivePlan.isMarkedToKeepEmpty = sourceSeat.isMarkedToKeepEmpty;
                            targetSeatInActivePlan.colorState = sourceSeat.colorState;
                            targetSeatInActivePlan.groupId = sourceSeat.groupId;
                            targetSeatInActivePlan.groupStyleType = sourceSeat.groupStyleType;
                        }
                    }
                });

                classNameInput.value = activePlan.className;
                roomNameInput.value = activePlan.roomName;
                commentInput.value = activePlan.comment;
                groupEditorInput.value = activePlan.groupSetting;
                activePlan.areGroupsActive = activePlan.seatData.some(s => s.groupId !== null);
                const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');
                if (groupsButtonTextSpan) {
                    groupsButtonTextSpan.textContent = activePlan.areGroupsActive ? "Gr. löschen" : "Gruppen";
                }

                messageArea.textContent = `Raumplan und Sitzordnung von '${sourcePlan.planName}' übernommen.`;
                renderGridForActivePlan();
            });


            // --- Zufallsauswahl ---
            randomSelectButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                if (randomAnimationTimeoutId) {
                    clearTimeout(randomAnimationTimeoutId);
                }

                if (activePlan.finalRandomSeatIndex !== -1) {
                    const prevFinalSeatDiv = document.getElementById(`seat-${activePlan.finalRandomSeatIndex}`);
                    if (prevFinalSeatDiv) prevFinalSeatDiv.classList.remove('random-selected-final');
                    activePlan.finalRandomSeatIndex = -1;
                }
                if (currentRandomHighlightIndex !== -1) {
                    const prevAnimSeatDiv = document.getElementById(`seat-${currentRandomHighlightIndex}`);
                    if (prevAnimSeatDiv) prevAnimSeatDiv.classList.remove('random-highlight-animation');
                    currentRandomHighlightIndex = -1;
                }

                const availableSeatsForRandom = activePlan.seatData
                    .map((seat, index) => !seat.isMarkedToKeepEmpty ? index : -1)
                    .filter(index => index !== -1);

                if (availableSeatsForRandom.length === 0) {
                    messageArea.textContent = "Keine Plätze für Zufallsauswahl verfügbar (alle sind als 'freihalten' markiert).";
                    return;
                }

                assignAllButton.disabled = true;
                generateGroupsButton.disabled = true;
                savePlanButton.disabled = true;
                loadPlanButton.disabled = true;
                downloadPdfButton.disabled = true;
                randomSelectButton.disabled = true;
                toggleRoomEditorButton.disabled = true;


                let startTime = Date.now();
                const duration = 5000;
                let nextTimeout = 50;
                const maxTimeout = 450;

                function animateStep() {
                    const elapsedTime = Date.now() - startTime;

                    if (currentRandomHighlightIndex !== -1) {
                        const prevSeatDiv = document.getElementById(`seat-${currentRandomHighlightIndex}`);
                        if (prevSeatDiv) prevSeatDiv.classList.remove('random-highlight-animation');
                    }

                    if (elapsedTime < duration) {
                        const randomIndexInAvailable = Math.floor(Math.random() * availableSeatsForRandom.length);
                        currentRandomHighlightIndex = availableSeatsForRandom[randomIndexInAvailable];

                        const currentSeatDiv = document.getElementById(`seat-${currentRandomHighlightIndex}`);
                        if (currentSeatDiv) currentSeatDiv.classList.add('random-highlight-animation');

                        const progress = elapsedTime / duration;
                        nextTimeout = 50 + Math.pow(progress, 3) * (maxTimeout - 50);
                        if (nextTimeout > maxTimeout) nextTimeout = maxTimeout;

                        randomAnimationTimeoutId = setTimeout(animateStep, nextTimeout);
                    } else {
                        activePlan.finalRandomSeatIndex = currentRandomHighlightIndex;
                        if (activePlan.finalRandomSeatIndex !== -1) {
                            const finalSeatDiv = document.getElementById(`seat-${activePlan.finalRandomSeatIndex}`);
                            if (finalSeatDiv) {
                                finalSeatDiv.classList.remove('random-highlight-animation');
                                finalSeatDiv.classList.add('random-selected-final');
                            }
                        }

                        assignAllButton.disabled = false;
                        generateGroupsButton.disabled = false;
                        savePlanButton.disabled = false;
                        loadPlanButton.disabled = false;
                        downloadPdfButton.disabled = false;
                        randomSelectButton.disabled = false;
                        toggleRoomEditorButton.disabled = false;
                        currentRandomHighlightIndex = -1;
                        randomAnimationTimeoutId = null;
                    }
                }
                animateStep();
            });


            // --- Speicher- und Ladefunktionen ---
            savePlanButton.addEventListener('click', () => {
                updateActivePlanDataFromUI();

                const dataToSave = {
                    plans: plans,
                    activePlanId: activePlanId
                };
                const dataStr = JSON.stringify(dataToSave, null, 2);
                const dataBlob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(dataBlob);

                const downloadLink = document.createElement('a');
                downloadLink.href = url;
                downloadLink.download = 'sitzplan_daten_alle_plaene.json';
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
                URL.revokeObjectURL(url);
                messageArea.textContent = "Alle Pläne gespeichert.";
            });

            loadPlanButton.addEventListener('click', () => {
                loadFileInput.click();
            });

            loadFileInput.addEventListener('change', (event) => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (activePlan && activePlan.finalRandomSeatIndex !== -1) {
                    const prevFinalSeatDiv = document.getElementById(`seat-${activePlan.finalRandomSeatIndex}`);
                    if (prevFinalSeatDiv) prevFinalSeatDiv.classList.remove('random-selected-final');
                    activePlan.finalRandomSeatIndex = -1;
                }

                const file = event.target.files[0];
                if (!file) { return; }
                if (!file.name.endsWith('.json')) {
                    messageArea.textContent = "Fehler: Bitte eine .json Datei auswählen.";
                    loadFileInput.value = '';
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedFileData = JSON.parse(e.target.result);
                        if (loadedFileData && Array.isArray(loadedFileData.plans) && loadedFileData.activePlanId) {
                            plans = loadedFileData.plans;
                            plans.forEach(plan => {
                                plan.comment = plan.comment || "";
                                plan.groupSetting = plan.groupSetting || "";
                                plan.isCustomLayoutActive = plan.isCustomLayoutActive || false;
                                plan.customLayoutSeatDefinitions = plan.customLayoutSeatDefinitions || [];
                                plan.NUM_SEATS_EFFECTIVE = plan.NUM_SEATS_EFFECTIVE || (plan.isCustomLayoutActive ? plan.customLayoutSeatDefinitions.length : DEFAULT_NUM_SEATS);
                                if (plan.isCustomLayoutActive) {
                                    calculateUsedBoundsForPlan(plan);
                                } else {
                                    plan.minUsedRow = 0; plan.maxUsedRow = EDITOR_ROWS - 1;
                                    plan.minUsedCol = 0; plan.maxUsedCol = EDITOR_COLS - 1;
                                }
                                plan.areGroupsActive = plan.seatData.some(seat => seat.groupId !== null);
                                plan.finalRandomSeatIndex = plan.finalRandomSeatIndex || -1;
                            });
                            setActivePlan(loadedFileData.activePlanId);
                            messageArea.textContent = "Pläne erfolgreich geladen.";
                        } else {
                            throw new Error("Ungültiges Dateiformat oder fehlende Daten.");
                        }
                    } catch (error) {
                        console.error("Fehler beim Laden der Datei:", error);
                        messageArea.textContent = `Fehler beim Laden: ${error.message}`;
                    } finally {
                        loadFileInput.value = '';
                    }
                };
                reader.onerror = () => {
                    messageArea.textContent = "Fehler beim Lesen der Datei.";
                    loadFileInput.value = '';
                }
                reader.readAsText(file);
            });

            // --- Gruppenbildung ---
            function parseGroupInputFromEditor() {
                const input = groupEditorInput.value.trim().toLowerCase();
                if (!input) return null;

                if (input.startsWith('g')) {
                    const size = parseInt(input.substring(1));
                    if (!isNaN(size) && size > 0) {
                        return { type: 'size', value: size };
                    }
                } else {
                    const count = parseInt(input);
                    if (!isNaN(count) && count > 0) {
                        return { type: 'count', value: count };
                    }
                }
                return null;
            }

            function createGroupColorSwatches() {
                groupEditorColorSwatchesDiv.innerHTML = '';

                const fillSwatchesRow = document.createElement('div');
                fillSwatchesRow.classList.add('color-swatch-row');

                const stripesSwatchesRow = document.createElement('div');
                stripesSwatchesRow.classList.add('color-swatch-row');
                stripesSwatchesRow.style.marginTop = '0.5rem';

                for (let i = 0; i < GROUP_COLORS_COUNT; i++) {
                    const swatchFill = document.createElement('div');
                    swatchFill.classList.add('color-swatch', `group-fill-${i}`);
                    swatchFill.draggable = true;
                    swatchFill.dataset.groupId = i;
                    swatchFill.dataset.groupStyleType = 'fill';
                    swatchFill.addEventListener('dragstart', handleDragStart);
                    fillSwatchesRow.appendChild(swatchFill);

                    const swatchStripes = document.createElement('div');
                    swatchStripes.classList.add('color-swatch', `group-stripes-${i}`);
                    swatchStripes.draggable = true;
                    swatchStripes.dataset.groupId = i;
                    swatchStripes.dataset.groupStyleType = 'stripes';
                    swatchStripes.addEventListener('dragstart', handleDragStart);
                    stripesSwatchesRow.appendChild(swatchStripes);
                }

                groupEditorColorSwatchesDiv.appendChild(fillSwatchesRow);
                groupEditorColorSwatchesDiv.appendChild(stripesSwatchesRow);
            }


            // KORREKTUR: Vereinfachte Logik zum Umschalten der Sichtbarkeit
            generateGroupsButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;
                const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');

                if (activePlan.areGroupsActive) {
                    // Logik zum Löschen von Gruppen
                    activePlan.seatData.forEach(seat => {
                        seat.groupId = null;
                        seat.groupStyleType = null;
                    });
                    if (groupsButtonTextSpan) groupsButtonTextSpan.textContent = "Gruppen";
                    activePlan.areGroupsActive = false;
                    groupEditorContainer.classList.add('hidden');
                    renderGridForActivePlan();
                    messageArea.textContent = "Gruppen gelöscht.";
                } else {
                    // Logik zum Öffnen des Gruppen-Editors
                    // Zuerst das andere Panel sicher ausblenden
                    roomEditorContainer.classList.add('hidden');
                    toggleRoomEditorButton.querySelector('span[data-text-content]').textContent = "Raumeditor";

                    // Gruppen-Editor anzeigen
                    groupEditorContainer.classList.remove('hidden');
                    createGroupColorSwatches();
                    if (groupsButtonTextSpan) groupsButtonTextSpan.textContent = "Gr. löschen";
                }
            });

            closeGroupEditorButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;
                const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');
                if (groupsButtonTextSpan) {
                    groupsButtonTextSpan.textContent = activePlan.areGroupsActive ? "Gr. löschen" : "Gruppen";
                }
                groupEditorContainer.classList.add('hidden');
            });

            generateRandomGroupsButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                const groupParams = parseGroupInputFromEditor();
                if (!groupParams) {
                    messageArea.textContent = "Ungültige Eingabe für Gruppen. Z.B. '4' für Anzahl oder 'G3' für Größe.";
                    return;
                }

                if (activePlan.finalRandomSeatIndex !== -1) {
                    const prevFinalSeatDiv = document.getElementById(`seat-${activePlan.finalRandomSeatIndex}`);
                    if (prevFinalSeatDiv) prevFinalSeatDiv.classList.remove('random-selected-final');
                    activePlan.finalRandomSeatIndex = -1;
                }

                activePlan.seatData.forEach(seat => {
                    seat.colorState = 0;
                    seat.groupId = null;
                    seat.groupStyleType = null;
                });

                const occupiedSeatIndices = activePlan.seatData
                    .map((seat, index) => (seat.student && !seat.isMarkedToKeepEmpty) ? index : -1)
                    .filter(index => index !== -1);

                if (occupiedSeatIndices.length === 0) {
                    messageArea.textContent = "Keine belegten Plätze für Gruppenbildung vorhanden.";
                    renderGridForActivePlan();
                    return;
                }

                let shuffledOccupiedIndices = [...occupiedSeatIndices].sort(() => 0.5 - Math.random());
                let currentGroupIdCycle = 0;
                let groupMembers = [];

                if (groupParams.type === 'count') {
                    const numGroups = groupParams.value;
                    if (numGroups <= 0) {
                        messageArea.textContent = "Anzahl der Gruppen muss größer als 0 sein.";
                        return;
                    }
                    const baseGroupSize = Math.floor(shuffledOccupiedIndices.length / numGroups);
                    let remainder = shuffledOccupiedIndices.length % numGroups;

                    let studentIdx = 0;
                    for (let i = 0; i < numGroups; i++) {
                        groupMembers[i] = [];
                        const currentGroupActualSize = baseGroupSize + (remainder > 0 ? 1 : 0);
                        for (let j = 0; j < currentGroupActualSize; j++) {
                            if (studentIdx < shuffledOccupiedIndices.length) {
                                const seatIndex = shuffledOccupiedIndices[studentIdx];
                                activePlan.seatData[seatIndex].groupId = i;
                                groupMembers[i].push(seatIndex);
                                studentIdx++;
                            }
                        }
                        if (remainder > 0) remainder--;
                    }

                } else if (groupParams.type === 'size') {
                    const groupSize = groupParams.value;
                    if (groupSize <= 0) {
                        messageArea.textContent = "Gruppengröße muss größer als 0 sein.";
                        return;
                    }
                    for (let i = 0; i < shuffledOccupiedIndices.length; i++) {
                        if (i % groupSize === 0) {
                            currentGroupIdCycle = Math.floor(i / groupSize);
                            groupMembers[currentGroupIdCycle] = [];
                        }
                        const seatIndex = shuffledOccupiedIndices[i];
                        activePlan.seatData[seatIndex].groupId = currentGroupIdCycle;
                        groupMembers[currentGroupIdCycle].push(seatIndex);
                    }
                }

                const totalNumGroupsFormed = groupMembers.length;
                groupMembers.forEach((membersInGroup, grpId) => {
                    let style;
                    if (totalNumGroupsFormed <= GROUP_COLORS_COUNT) {
                        style = 'fill';
                    } else {
                        const styleTypeDeterminer = Math.floor(grpId / 8);
                        style = (styleTypeDeterminer % 2 === 0) ? 'fill' : 'stripes';
                    }
                    membersInGroup.forEach(seatIdx => {
                        activePlan.seatData[seatIdx].groupStyleType = style;
                    });
                });

                activePlan.areGroupsActive = true;
                const groupsButtonTextSpan = generateGroupsButton.querySelector('span[data-text-content]');
                if (groupsButtonTextSpan) {
                    groupsButtonTextSpan.textContent = "Gr. löschen";
                }
                renderGridForActivePlan();
            });

            insertTestClassButton.addEventListener('click', () => {
                const activePlan = plans.find(p => p.planId === activePlanId);
                if (!activePlan) return;

                const maleNames = ["Max Mustermann", "Tom Mustermann", "Paul Mustermann", "Leon Mustermann", "Finn Mustermann", "Noah Mustermann", "Elias Mustermann", "Ben Mustermann", "Luca Mustermann", "Felix Mustermann", "Jonas Mustermann", "Louis Mustermann", "Anton Mustermann", "Emil Mustermann", "Oskar Mustermann"];
                const femaleNames = ["Erika Musterfrau", "Anna Musterfrau", "Mia Musterfrau", "Emma Musterfrau", "Sophia Musterfrau", "Hannah Musterfrau", "Emilia Musterfrau", "Lina Musterfrau", "Marie Musterfrau", "Clara Musterfrau", "Lea Musterfrau", "Lena Musterfrau", "Laura Musterfrau", "Sarah Musterfrau", "Ida Musterfrau"];
                const testStudents = maleNames.concat(femaleNames);

                studentNamesTextarea.value = testStudents.join(',\n');
                parseStudentNamesAndUpdateActivePlan();

                classNameInput.value = "Testklasse";
                roomNameInput.value = "Raum 00";
                commentInput.value = "Testplan";
                updateActivePlanDataFromUI();

                if (activePlan.NUM_SEATS_EFFECTIVE === 0 && !activePlan.isCustomLayoutActive) {
                    activePlan.isCustomLayoutActive = true;
                    activePlan.NUM_SEATS_EFFECTIVE = DEFAULT_NUM_SEATS;
                    activePlan.customLayoutSeatDefinitions = [...PREDEFINED_DEFAULT_LAYOUT_SEAT_DEFINITIONS];
                    calculateUsedBoundsForPlan(activePlan);
                    initializeSeatDataForPlan(activePlan);
                }

                performFullSeatAssignment(activePlan);
                messageArea.textContent = "Testklasse eingefügt und Plätze zugewiesen.";
            });


            // --- PDF Download Funktion ---
            downloadPdfButton.addEventListener('click', () => {
                if (!jsPDF) {
                    messageArea.textContent = "PDF-Funktion ist nicht verfügbar.";
                    return;
                }
                updateActivePlanDataFromUI();

                if (plans.length === 0 || plans.every(p => p.NUM_SEATS_EFFECTIVE === 0)) {
                    messageArea.textContent = "Bitte erstelle oder lade mindestens einen Plan mit Sitzen, um ein PDF zu generieren.";
                    return;
                }

                const doc = new jsPDF({
                    orientation: 'landscape',
                    unit: 'mm',
                    format: 'a4'
                });
                const pageWidth = doc.internal.pageSize.getWidth();

                const pdfScaleFactor = 1.5;
                const baseFontSize = 8;
                const classFontSize = 12;
                const roomFontSize = 10;
                const commentFontSize = 8;
                const dateTimeFontSize = 7;
                const planNameFontSize = 14;


                plans.forEach((currentPlan, planIndex) => {
                    if (planIndex > 0) {
                        doc.addPage();
                    }
                    if (currentPlan.NUM_SEATS_EFFECTIVE === 0) return;

                    let yOffsetForDetails = 12 + (2 * pdfScaleFactor);

                    doc.setFontSize(planNameFontSize * pdfScaleFactor);
                    doc.text(currentPlan.planName, 14, yOffsetForDetails);
                    yOffsetForDetails += (planNameFontSize * pdfScaleFactor * 0.352778 / 2) + 5;

                    if (currentPlan.className) {
                        doc.setFontSize(classFontSize * pdfScaleFactor);
                        doc.text(`Klasse: ${currentPlan.className}`, 14, yOffsetForDetails);
                        yOffsetForDetails += (classFontSize * pdfScaleFactor * 0.352778 / 2) + 3;
                    }
                    if (currentPlan.roomName) {
                        doc.setFontSize(roomFontSize * pdfScaleFactor);
                        doc.text(`Raum: ${currentPlan.roomName}`, 14, yOffsetForDetails);
                        yOffsetForDetails += (roomFontSize * pdfScaleFactor * 0.352778 / 2) + 3;
                    }
                    if (currentPlan.comment) {
                        doc.setFontSize(commentFontSize * pdfScaleFactor);
                        const commentLines = doc.splitTextToSize(`Kommentar: ${currentPlan.comment}`, pageWidth - 28 - 50);
                        doc.text(commentLines, 14, yOffsetForDetails);
                        yOffsetForDetails += (commentLines.length * commentFontSize * pdfScaleFactor * 0.352778 / 2) + 3;
                    }


                    doc.setFontSize(dateTimeFontSize * pdfScaleFactor);
                    const now = new Date();
                    const dateStr = now.toLocaleDateString('de-DE', { day: '2-digit', month: '2-digit', year: 'numeric' });
                    const timeStr = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
                    const dateTimeFullStr = `${dateStr} - ${timeStr} Uhr`;
                    doc.text(dateTimeFullStr, pageWidth - 14, 12 + (2 * pdfScaleFactor), { align: 'right' });


                    doc.setFontSize(baseFontSize * pdfScaleFactor);

                    const pdfSeatWidth = 20 * pdfScaleFactor;
                    const pdfSeatHeight = 15 * pdfScaleFactor;
                    const pdfPairInternalGap = 2 * pdfScaleFactor;
                    const pdfGapBetweenPairs = 3 * pdfScaleFactor;
                    const pdfCentralGap = 10 * pdfScaleFactor;
                    const pdfRowToRowGap = 7 * pdfScaleFactor;
                    const pdfDeskHeight = pdfSeatHeight;

                    const pairBlockWidth = pdfSeatWidth * 2 + pdfPairInternalGap;
                    const halfRowWidth = pairBlockWidth * 2 + pdfGapBetweenPairs;
                    const totalSeatLayoutWidthDefault = halfRowWidth * 2 + pdfCentralGap;
                    const pdfDeskWidth = halfRowWidth;

                    let layoutStartX = (pageWidth - totalSeatLayoutWidthDefault) / 2;
                    let yPosForRow = yOffsetForDetails + 5;

                    if (currentPlan.isCustomLayoutActive) {
                        const numActiveCols = (currentPlan.maxUsedCol - currentPlan.minUsedCol + 1);
                        let customPdfSeatWidth = Math.min(pdfSeatWidth, (pageWidth - 28 - ((numActiveCols -1) * pdfGapBetweenPairs)) / numActiveCols) ;
                        customPdfSeatWidth = Math.max(customPdfSeatWidth, 15 * pdfScaleFactor);

                        const customPdfSeatHeight = customPdfSeatWidth * (pdfSeatHeight / pdfSeatWidth);
                        const totalCustomWidth = numActiveCols * customPdfSeatWidth + (numActiveCols - 1) * pdfGapBetweenPairs;
                        layoutStartX = (pageWidth - totalCustomWidth) / 2;
                        let currentX = layoutStartX;

                        for (let r = currentPlan.minUsedRow; r <= currentPlan.maxUsedRow; r++) {
                            currentX = layoutStartX;
                            for (let c = currentPlan.minUsedCol; c <= currentPlan.maxUsedCol; c++) {
                                const editorGridIdx = r * EDITOR_COLS + c;
                                const seatInfo = currentPlan.seatData.find(sd => sd.originalGridIndex === editorGridIdx);
                                if (seatInfo) {
                                    drawSeatOnPdf(doc, currentX, yPosForRow, customPdfSeatWidth, customPdfSeatHeight, seatInfo, pdfScaleFactor, currentPlan.allParsedStudentsList);
                                }
                                currentX += customPdfSeatWidth + pdfGapBetweenPairs;
                            }
                            yPosForRow += customPdfSeatHeight + pdfRowToRowGap;
                        }
                        yPosForRow -= pdfRowToRowGap;
                    } else {
                        for (let r = 0; r < 4; r++) {
                            let currentX = layoutStartX;
                            // Linke Hälfte der Reihe
                            for (let p = 0; p < DEFAULT_PAIRS_PER_ROW / 2; p++) {
                                const seat1Idx = r * DEFAULT_SEATS_PER_ROW + p * DEFAULT_SEATS_PER_PAIR;
                                const seat2Idx = seat1Idx + 1;
                                if(currentPlan.seatData[seat1Idx]) drawSeatOnPdf(doc, currentX, yPosForRow, pdfSeatWidth, pdfSeatHeight, currentPlan.seatData[seat1Idx], pdfScaleFactor, currentPlan.allParsedStudentsList);
                                currentX += pdfSeatWidth + pdfPairInternalGap;
                                if(currentPlan.seatData[seat2Idx]) drawSeatOnPdf(doc, currentX, yPosForRow, pdfSeatWidth, pdfSeatHeight, currentPlan.seatData[seat2Idx], pdfScaleFactor, currentPlan.allParsedStudentsList);
                                currentX += pdfSeatWidth + pdfGapBetweenPairs;
                            }

                            currentX = layoutStartX + halfRowWidth + pdfCentralGap;

                            // Rechte Hälfte der Reihe
                            for (let p = DEFAULT_PAIRS_PER_ROW / 2; p < DEFAULT_PAIRS_PER_ROW; p++) {
                                const seat1Idx = r * DEFAULT_SEATS_PER_ROW + p * DEFAULT_SEATS_PER_PAIR;
                                const seat2Idx = seat1Idx + 1;
                                if(currentPlan.seatData[seat1Idx]) drawSeatOnPdf(doc, currentX, yPosForRow, pdfSeatWidth, pdfSeatHeight, currentPlan.seatData[seat1Idx], pdfScaleFactor, currentPlan.allParsedStudentsList);
                                currentX += pdfSeatWidth + pdfPairInternalGap;
                                if(currentPlan.seatData[seat2Idx]) drawSeatOnPdf(doc, currentX, yPosForRow, pdfSeatWidth, pdfSeatHeight, currentPlan.seatData[seat2Idx], pdfScaleFactor, currentPlan.allParsedStudentsList);
                                currentX += pdfSeatWidth + pdfGapBetweenPairs;
                            }
                            yPosForRow += pdfSeatHeight + pdfRowToRowGap;
                        }
                    }

                    const deskX = (pageWidth - pdfDeskWidth) / 2;
                    const deskY = yPosForRow + (5 * pdfScaleFactor);

                    doc.setFillColor(203, 213, 225);
                    doc.setDrawColor(148, 163, 184);
                    doc.rect(deskX, deskY, pdfDeskWidth, pdfDeskHeight, 'FD');
                    doc.setTextColor(51, 65, 85);
                    doc.setFontSize(10 * pdfScaleFactor);
                    doc.text("Pult", deskX + pdfDeskWidth / 2, deskY + pdfDeskHeight / 2, { align: 'center', baseline: 'middle' });
                });

                doc.save('sitzplan.pdf');
            });

            function drawSeatOnPdf(doc, x, y, w, h, seatInfo, scaleFactor, planStudentList) {
                const originalDrawColor = doc.getDrawColor();
                const originalLineWidth = doc.getLineWidth();

                doc.setDrawColor(209, 213, 219);
                doc.setLineWidth(0.2 * scaleFactor);
                doc.setFillColor(243, 244, 246);

                const groupPdfFillColors = [
                    [255,0,0], [42,26,255], [250,255,0], [0,255,10], [255,0,153],
                    [141,26,255], [0,255,224], [201,119,0], [0,109,23], [141,141,141]
                ];
                const groupPdfBorderColors = [
                    [204,0,0], [14,0,204], [200,204,0], [0,204,8], [204,0,122],
                    [113,0,204], [0,204,179], [161,95,0], [0,87,18], [100,100,100]
                ];

                let isGroupBorderNeededForPdf = false;

                if (seatInfo.groupId !== null) {
                    const colorIndex = seatInfo.groupId % GROUP_COLORS_COUNT;
                    doc.setFillColor(...groupPdfFillColors[colorIndex]);

                    if (seatInfo.groupStyleType === 'stripes') {
                        isGroupBorderNeededForPdf = true;
                    }
                } else if (seatInfo.colorState === 1) {
                    doc.setFillColor(167, 243, 208);
                } else if (seatInfo.colorState === 2) {
                    doc.setFillColor(253, 230, 138);
                } else if (seatInfo.colorState === 3) {
                    doc.setFillColor(254, 202, 202);
                } else {
                    if (seatInfo.student) {
                        doc.setFillColor(219, 234, 254);
                    }
                }
                doc.rect(x, y, w, h, 'FD');

                if (isGroupBorderNeededForPdf) {
                    const colorIndex = seatInfo.groupId % GROUP_COLORS_COUNT;
                    doc.setDrawColor(...groupPdfBorderColors[colorIndex]);
                    doc.setLineWidth(1 * scaleFactor);
                    doc.rect(x, y, w, h, 'S');
                }

                if (seatInfo.isMarkedToKeepEmpty) {
                    doc.setDrawColor(249, 115, 22);
                    doc.setLineWidth(1.2 * scaleFactor);
                    doc.rect(x, y, w, h, 'S');
                }


                doc.setTextColor(0, 0, 0);
                const fontSize = 6 * scaleFactor;
                doc.setFontSize(fontSize);

                let studentNameToDisplay = "Frei";
                if (seatInfo.student) {
                    const studentObject = planStudentList.find(s => s.originalName === seatInfo.student);
                    studentNameToDisplay = studentObject ? studentObject.displayName : seatInfo.student.replace(/[\d*]+$/, '').trim();
                }

                const maxWidth = w - (3.5 * scaleFactor);
                let finalLines = [];

                if (studentNameToDisplay === "Frei" || studentNameToDisplay.trim() === "") {
                    finalLines = ["Frei"];
                } else {
                    const words = studentNameToDisplay.trim().split(/\s+/);
                    let linesForThisName = [];

                    if (words.length > 1) {
                        const firstWord = words[0];
                        const restOfName = words.slice(1).join(' ');

                        linesForThisName = doc.splitTextToSize(firstWord, maxWidth);
                        if (restOfName.trim().length > 0) {
                            linesForThisName = linesForThisName.concat(doc.splitTextToSize(restOfName, maxWidth));
                        }
                    } else {
                        linesForThisName = doc.splitTextToSize(studentNameToDisplay.trim(), maxWidth);
                    }
                    finalLines = linesForThisName;
                }

                finalLines = finalLines.filter(line => line.trim().length > 0);
                if (finalLines.length === 0 && studentNameToDisplay.trim() !== "" && studentNameToDisplay !== "Frei") {
                    finalLines = doc.splitTextToSize(studentNameToDisplay.trim(), maxWidth);
                }
                if (finalLines.length === 0 && studentNameToDisplay === "Frei") {
                    finalLines = ["Frei"];
                }

                const approxLineHeight = 2.2 * scaleFactor * (fontSize / 6);
                const verticalPadding = 1.5 * scaleFactor;
                const maxLinesAllowed = Math.max(1, Math.floor((h - verticalPadding * 2) / approxLineHeight));

                if (finalLines.length > maxLinesAllowed) {
                    const originalLength = finalLines.length;
                    finalLines = finalLines.slice(0, maxLinesAllowed);
                    if (finalLines.length > 0 && originalLength > maxLinesAllowed) {
                        let lastLineIdx = finalLines.length - 1;
                        let lastLineContent = finalLines[lastLineIdx];
                        if (lastLineContent.length > 3) {
                            finalLines[lastLineIdx] = lastLineContent.substring(0, lastLineContent.length - 2) + "..";
                        } else {
                            finalLines[lastLineIdx] = "..";
                        }
                    }
                }

                if(finalLines.length === 0 && studentNameToDisplay.trim() !== "" && studentNameToDisplay !== "Frei") {
                    finalLines.push("...");
                }
                if(finalLines.length === 0 && studentNameToDisplay === "Frei") {
                    finalLines.push("Frei");
                }

                if (seatInfo.groupId !== null) {
                    const colorIndex = seatInfo.groupId % GROUP_COLORS_COUNT;
                    const rgbFill = groupPdfFillColors[colorIndex];
                    let textColor = [0,0,0];

                    if (seatInfo.groupStyleType === 'stripes') {
                        if (colorIndex === 1 || colorIndex === 5 || colorIndex === 8) {
                            textColor = [255,255,255];
                        } else {
                            textColor = [0,0,0];
                        }
                    } else {
                        const luminance = (0.299 * rgbFill[0] + 0.587 * rgbFill[1] + 0.114 * rgbFill[2]) / 255;
                        if (luminance > 0.5 && !(colorIndex === 2 || colorIndex === 3 || colorIndex === 6)) {
                            textColor = [0,0,0];
                        } else if (luminance <= 0.5 || (colorIndex === 2 || colorIndex === 3 || colorIndex === 6)) {
                            if (colorIndex === 2 || colorIndex === 3 || colorIndex === 6) textColor = [0,0,0];
                            else textColor = [255,255,255];
                        }
                    }
                    doc.setTextColor(...textColor);

                } else if (seatInfo.colorState === 1) { doc.setTextColor(6,95,70);
                } else if (seatInfo.colorState === 2) { doc.setTextColor(146,64,14);
                } else if (seatInfo.colorState === 3) { doc.setTextColor(153,27,27);
                } else if (seatInfo.student) { doc.setTextColor(30,64,175);
                } else { doc.setTextColor(107,114,128);
                }


                doc.text(finalLines, x + w / 2, y + h / 2, { align: 'center', baseline: 'middle' });

                doc.setDrawColor(originalDrawColor[0], originalDrawColor[1], originalDrawColor[2]);
                doc.setLineWidth(originalLineWidth);
            }

            // Initialisierung beim Laden der Seite
            addTabButton.addEventListener('click', addTab);
            addTab();
        });
    </script>
</body>
</html>
